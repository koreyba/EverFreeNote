name: Component Tests

on:
  push:
    branches: [main, develop, github-actions-setup]
  pull_request:
  workflow_dispatch:

permissions:
  actions: read
  contents: read

jobs:
  component-tests:
    runs-on: ubuntu-latest
    environment: Stage
    env:
      NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL || secrets.SUPABASE_URL }}
      NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY || secrets.SUPABASE_ANON_KEY }}
      NEXT_PUBLIC_ENABLE_TEST_AUTH: ${{ vars.NEXT_PUBLIC_ENABLE_TEST_AUTH }}
      NEXT_PUBLIC_TEST_AUTH_EMAIL: ${{ secrets.NEXT_PUBLIC_TEST_AUTH_EMAIL }}
      NEXT_PUBLIC_TEST_AUTH_PASSWORD: ${{ secrets.NEXT_PUBLIC_TEST_AUTH_PASSWORD }}
      NEXT_PUBLIC_SKIP_AUTH_EMAIL: ${{ secrets.NEXT_PUBLIC_SKIP_AUTH_EMAIL }}
      NEXT_PUBLIC_SKIP_AUTH_PASSWORD: ${{ secrets.NEXT_PUBLIC_SKIP_AUTH_PASSWORD }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Run component tests
        id: run-component-tests
        run: |
          set -o pipefail
          mkdir -p cypress/results
          node <<'NODE' 2>&1 | tee cypress/results/component-tests.log
          const fs = require('fs');
          const path = require('path');
          const cypress = require('cypress');

          const resultsPath = path.resolve('cypress', 'results', 'component-results.json');
          const exitCodePath = path.resolve('cypress', 'results', 'component-exit-code.txt');
          const runOptions = {
            component: true,
            browser: 'electron',
            spec: 'cypress/component/**/*.cy.{js,jsx,ts,tsx}',
            reporter: 'spec',
          };

          const writeExitCode = (code) => {
            fs.writeFileSync(exitCodePath, String(code), 'utf8');
          };

          const persistResults = (payload) => {
            fs.writeFileSync(resultsPath, JSON.stringify(payload, null, 2), 'utf8');
          };

          const getSpecName = (run) => run?.spec?.relative || run?.spec?.name || 'unknown spec';

          const getRunTestsCount = (run) => {
            const statsTests = Number(run?.stats?.tests);
            if (Number.isFinite(statsTests)) return statsTests;
            if (Array.isArray(run?.tests)) return run.tests.length;
            return 0;
          };

          const collectZeroTestSpecs = (runs) =>
            (runs || [])
              .filter((run) => getRunTestsCount(run) === 0)
              .map((run) => getSpecName(run));

          const aggregateTotals = (runs) => {
            return (runs || []).reduce((acc, run) => {
              const stats = run?.stats || {};
              acc.totalSuites += Number(stats.suites || 0);
              acc.totalTests += Number(stats.tests || 0);
              acc.totalPassed += Number(stats.passes || 0);
              acc.totalFailed += Number(stats.failures || 0);
              acc.totalPending += Number(stats.pending || 0);
              acc.totalSkipped += Number(stats.skipped || 0);
              acc.totalDuration += Number(stats.duration || 0);
              return acc;
            }, {
              totalSuites: 0,
              totalTests: 0,
              totalPassed: 0,
              totalFailed: 0,
              totalPending: 0,
              totalSkipped: 0,
              totalDuration: 0,
            });
          };

          const attachDerivedTotals = (results) => {
            const runs = Array.isArray(results?.runs) ? results.runs : [];
            return {
              ...(results || {}),
              runs,
              ...aggregateTotals(runs),
            };
          };

          const mergeResults = (primary, retry, retriedSpecs) => {
            const retriedSet = new Set(retriedSpecs);
            const primaryRuns = (primary.runs || []).filter((run) => !retriedSet.has(getSpecName(run)));
            const retryRuns = retry.runs || [];
            const mergedRuns = [...primaryRuns, ...retryRuns];
            const status =
              primary.status === 'finished' && retry.status === 'finished'
                ? 'finished'
                : 'error';

            return {
              ...primary,
              runs: mergedRuns,
              status,
              ...aggregateTotals(mergedRuns),
            };
          };

          (async () => {
            try {
              const primaryResults = attachDerivedTotals(await cypress.run(runOptions));
              const zeroTestSpecsInitial = collectZeroTestSpecs(primaryResults.runs);

              let retryResults = null;
              let zeroTestSpecsAfterRetry = [...zeroTestSpecsInitial];

              if (zeroTestSpecsInitial.length > 0) {
                console.warn(`Detected ${zeroTestSpecsInitial.length} specs with zero registered tests on primary run. Retrying those specs in a fresh Cypress run...`);
                for (const specName of zeroTestSpecsInitial) {
                  console.warn(` - ${specName}`);
                }

                retryResults = attachDerivedTotals(await cypress.run({
                  ...runOptions,
                  spec: zeroTestSpecsInitial.join(','),
                }));

                const retryZeroSet = new Set(collectZeroTestSpecs(retryResults.runs));
                zeroTestSpecsAfterRetry = zeroTestSpecsInitial.filter((specName) => retryZeroSet.has(specName));
              }

              const finalResults = retryResults
                ? mergeResults(primaryResults, retryResults, zeroTestSpecsInitial)
                : primaryResults;

              const persistedResults = {
                ...finalResults,
                zeroTestSpecsInitial,
                retriedZeroTestSpecs: zeroTestSpecsInitial,
                zeroTestSpecsAfterRetry,
                retryAttempted: zeroTestSpecsInitial.length > 0,
              };

              persistResults(persistedResults);

              const totalFailed = Number(persistedResults?.totalFailed || 0);
              const hasFatalRunError = persistedResults?.status && persistedResults.status !== 'finished';
              const exitCode = totalFailed > 0 || hasFatalRunError || zeroTestSpecsAfterRetry.length > 0 ? 1 : 0;
              writeExitCode(exitCode);

              if (exitCode !== 0) {
                console.error(`Component tests completed with failure status. totalFailed=${totalFailed}, status=${persistedResults?.status}`);
                if (zeroTestSpecsAfterRetry.length > 0) {
                  console.error(`Specs still have zero registered tests after retry (${zeroTestSpecsAfterRetry.length}):`);
                  for (const specName of zeroTestSpecsAfterRetry) {
                    console.error(` - ${specName}`);
                  }
                }
              } else if (zeroTestSpecsInitial.length > 0) {
                console.log(`Recovered ${zeroTestSpecsInitial.length} zero-test specs after automatic retry.`);
              }

              // Keep this step green and fail exactly once in a dedicated final step.
              process.exit(0);
            } catch (error) {
              persistResults({
                status: 'error',
                error: error instanceof Error
                  ? { message: error.message, stack: error.stack }
                  : { message: String(error) },
              });
              writeExitCode(1);
              console.error('Component test runner crashed before completion.');
              console.error(error);
              process.exit(0);
            }
          })();
          NODE

      - name: Generate visual summary
        if: always()
        run: |
          node <<'NODE'
          const fs = require('fs');
          const path = require('path');

          const summaryFile = process.env.GITHUB_STEP_SUMMARY;
          const resultsPath = path.resolve('cypress', 'results', 'component-results.json');
          const exitCodePath = path.resolve('cypress', 'results', 'component-exit-code.txt');
          const logPath = path.resolve('cypress', 'results', 'component-tests.log');
          const screenshotsDir = path.resolve('cypress', 'screenshots');
          const videosDir = path.resolve('cypress', 'videos');

          const readTextIfExists = (filePath) => {
            if (!fs.existsSync(filePath)) return '';
            return fs.readFileSync(filePath, 'utf8');
          };

          const readJsonIfExists = (filePath) => {
            if (!fs.existsSync(filePath)) return null;
            return JSON.parse(fs.readFileSync(filePath, 'utf8'));
          };

          const collectFiles = (dirPath, extension) => {
            if (!fs.existsSync(dirPath)) return [];
            const out = [];
            const stack = [dirPath];
            while (stack.length > 0) {
              const current = stack.pop();
              for (const entry of fs.readdirSync(current, { withFileTypes: true })) {
                const full = path.join(current, entry.name);
                if (entry.isDirectory()) {
                  stack.push(full);
                } else if (entry.isFile() && full.toLowerCase().endsWith(extension)) {
                  out.push(full);
                }
              }
            }
            return out.sort();
          };

          const results = readJsonIfExists(resultsPath);
          const exitCode = Number(readTextIfExists(exitCodePath).trim() || '1');

          const passed = Number(results?.totalPassed || 0);
          const failed = Number(results?.totalFailed || 0);
          const pending = Number(results?.totalPending || 0);
          const skipped = Number(results?.totalSkipped || 0);
          const total = Number(results?.totalTests || passed + failed + pending + skipped);

          const screenshots = collectFiles(screenshotsDir, '.png');
          const videos = collectFiles(videosDir, '.mp4');

          const failedTitles = [];
          const runLevelErrors = [];
          const zeroTestSpecsFromRuns = [];

          for (const run of results?.runs || []) {
            const statsTests = Number(run?.stats?.tests);
            const hasZeroTests = Number.isFinite(statsTests)
              ? statsTests === 0
              : Array.isArray(run?.tests) && run.tests.length === 0;
            if (hasZeroTests) {
              zeroTestSpecsFromRuns.push(run.spec?.relative || run.spec?.name || 'unknown spec');
            }

            if (run?.error) {
              runLevelErrors.push({
                spec: run.spec?.relative || run.spec?.name || 'unknown spec',
                error: String(run.error).split('\n')[0],
              });
            }

            for (const test of run.tests || []) {
              if (test?.state !== 'failed') continue;
              const titlePath = Array.isArray(test.title) ? test.title.join(' > ') : String(test.title || 'failed test');
              failedTitles.push(`${run.spec?.relative || run.spec?.name || 'unknown spec'}: ${titlePath}`);
            }
          }

          const zeroTestSpecsInitial = Array.isArray(results?.zeroTestSpecsInitial)
            ? results.zeroTestSpecsInitial
            : zeroTestSpecsFromRuns;
          const retriedZeroTestSpecs = Array.isArray(results?.retriedZeroTestSpecs)
            ? results.retriedZeroTestSpecs
            : [];
          const zeroTestSpecsAfterRetry = Array.isArray(results?.zeroTestSpecsAfterRetry)
            ? results.zeroTestSpecsAfterRetry
            : zeroTestSpecsFromRuns;
          const recoveredZeroTestSpecs = zeroTestSpecsInitial.filter(
            (spec) => !zeroTestSpecsAfterRetry.includes(spec)
          );

          const headline = exitCode === 0 ? 'Component Tests Passed' : 'Component Tests Failed';

          let md = '';
          md += `## ${headline}\n\n`;
          md += '| Metric | Count |\n';
          md += '|---|---:|\n';
          md += `| Total | ${total} |\n`;
          md += `| Passed | ${passed} |\n`;
          md += `| Failed | ${failed} |\n`;
          md += `| Pending | ${pending} |\n`;
          md += `| Skipped | ${skipped} |\n`;
          md += `| Zero-test specs (initial) | ${zeroTestSpecsInitial.length} |\n`;
          md += `| Zero-test specs (after retry) | ${zeroTestSpecsAfterRetry.length} |\n`;
          md += `| Recovered by retry | ${recoveredZeroTestSpecs.length} |\n`;
          md += `| Screenshot artifacts | ${screenshots.length} |\n`;
          md += `| Video artifacts | ${videos.length} |\n\n`;

          if (!results) {
            md += 'Component result JSON was not found at `cypress/results/component-results.json`.\n\n';
          }

          if (!fs.existsSync(logPath)) {
            md += 'Component test log was not found at `cypress/results/component-tests.log`.\n\n';
          }

          if (failedTitles.length > 0) {
            md += '<details>\n';
            md += `<summary>Failed tests (${failedTitles.length})</summary>\n\n`;
            for (const title of failedTitles.slice(0, 30)) {
              md += `- ${title}\n`;
            }
            if (failedTitles.length > 30) {
              md += `\n- ... and ${failedTitles.length - 30} more\n`;
            }
            md += '\n</details>\n';
          }

          if (runLevelErrors.length > 0) {
            md += '\n<details>\n';
            md += `<summary>Spec runtime errors (${runLevelErrors.length})</summary>\n\n`;
            for (const item of runLevelErrors.slice(0, 20)) {
              md += `- \`${item.spec}\`: ${item.error}\n`;
            }
            if (runLevelErrors.length > 20) {
              md += `\n- ... and ${runLevelErrors.length - 20} more\n`;
            }
            md += '\n</details>\n';
          }

          if (retriedZeroTestSpecs.length > 0) {
            md += '\n<details>\n';
            md += `<summary>Retried zero-test specs (${retriedZeroTestSpecs.length})</summary>\n\n`;
            for (const spec of retriedZeroTestSpecs.slice(0, 30)) {
              md += `- \`${spec}\`\n`;
            }
            if (retriedZeroTestSpecs.length > 30) {
              md += `\n- ... and ${retriedZeroTestSpecs.length - 30} more\n`;
            }
            md += '\n</details>\n';
          }

          if (recoveredZeroTestSpecs.length > 0) {
            md += '\n<details>\n';
            md += `<summary>Recovered zero-test specs (${recoveredZeroTestSpecs.length})</summary>\n\n`;
            for (const spec of recoveredZeroTestSpecs.slice(0, 30)) {
              md += `- \`${spec}\`\n`;
            }
            if (recoveredZeroTestSpecs.length > 30) {
              md += `\n- ... and ${recoveredZeroTestSpecs.length - 30} more\n`;
            }
            md += '\n</details>\n';
          }

          if (zeroTestSpecsAfterRetry.length > 0) {
            md += '\n<details>\n';
            md += `<summary>Specs still with zero tests after retry (${zeroTestSpecsAfterRetry.length})</summary>\n\n`;
            for (const spec of zeroTestSpecsAfterRetry.slice(0, 30)) {
              md += `- \`${spec}\`\n`;
            }
            if (zeroTestSpecsAfterRetry.length > 30) {
              md += `\n- ... and ${zeroTestSpecsAfterRetry.length - 30} more\n`;
            }
            md += '\n</details>\n';
          }

          if (screenshots.length > 0) {
            md += '\n<details>\n';
            md += `<summary>Failed screenshots (${screenshots.length})</summary>\n\n`;
            for (const filePath of screenshots.slice(0, 20)) {
              md += `- \`${path.relative(process.cwd(), filePath)}\`\n`;
            }
            if (screenshots.length > 20) {
              md += `\n- ... and ${screenshots.length - 20} more\n`;
            }
            md += '\n</details>\n';
          }

          fs.appendFileSync(summaryFile, md);
          NODE

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: component-test-results-${{ github.run_id }}
          path: |
            cypress/results/component-results.json
            cypress/results/component-exit-code.txt
            cypress/results/component-tests.log
            cypress/screenshots
            cypress/videos
          if-no-files-found: ignore
          retention-days: 30

      - name: Mark job as failed when component tests failed
        if: always()
        run: |
          exit_code_file="cypress/results/component-exit-code.txt"
          if [ ! -f "$exit_code_file" ]; then
            echo "Component exit code file not found: $exit_code_file"
            exit 1
          fi

          component_exit_code="$(cat "$exit_code_file" | tr -d '[:space:]')"
          if [ "$component_exit_code" != "0" ]; then
            echo "Component tests failed with exit code $component_exit_code"
            exit 1
          fi
