name: E2E Tests (PR Preview)

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
  workflow_dispatch:
    inputs:
      preview_url:
        description: 'Cloudflare preview URL to test against'
        required: true
        type: string
      e2e_branch:
        description: 'E2E repo branch (leave empty for auto-detect / master)'
        required: false
        default: ''
        type: string

permissions:
  contents: read
  pull-requests: read
  deployments: read
  checks: read

concurrency:
  group: e2e-${{ github.event.pull_request.number || github.run_id }}
  cancel-in-progress: true

jobs:
  resolve-e2e-branch:
    name: Resolve E2E branch
    runs-on: ubuntu-latest
    outputs:
      e2e_ref: ${{ steps.resolve.outputs.e2e_ref }}

    steps:
      - name: Determine E2E test branch
        id: resolve
        env:
          INPUT_BRANCH: ${{ inputs.e2e_branch }}
          PR_HEAD_REF: ${{ github.event.pull_request.head.ref }}
        run: |
          set -euo pipefail

          # Priority: manual input > matching PR branch name > master
          if [ -n "${INPUT_BRANCH}" ]; then
            echo "Using manually specified branch: ${INPUT_BRANCH}"
            echo "e2e_ref=${INPUT_BRANCH}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [ -n "${PR_HEAD_REF}" ]; then
            echo "Checking if branch '${PR_HEAD_REF}' exists in EverFreeNote-e2e..."
            if git ls-remote --exit-code --heads "https://github.com/koreyba/EverFreeNote-e2e.git" "refs/heads/${PR_HEAD_REF}" > /dev/null 2>&1; then
              echo "Found matching branch: ${PR_HEAD_REF}"
              echo "e2e_ref=${PR_HEAD_REF}" >> "$GITHUB_OUTPUT"
              exit 0
            fi
            echo "No matching branch found"
          fi

          echo "Using default branch: master"
          echo "e2e_ref=master" >> "$GITHUB_OUTPUT"

  wait-cloudflare-preview:
    name: Wait for Cloudflare Preview
    if: github.event_name == 'pull_request' && !github.event.pull_request.draft
    runs-on: ubuntu-latest
    timeout-minutes: 35
    outputs:
      preview_url: ${{ steps.wait.outputs.preview_url }}

    steps:
      - name: Wait for successful Cloudflare deployment status
        id: wait
        env:
          GH_TOKEN: ${{ github.token }}
          REPO: ${{ github.repository }}
          SHA: ${{ github.event.pull_request.head.sha }}
        run: |
          set -euo pipefail

          deadline=$((SECONDS + 1800))
          interval=15

          extract_pages_url() {
            local raw="$1"
            printf '%s\n' "$raw" |
              grep -Eo "https://[^\"'<>[:space:]]+" |
              grep -E "\.pages\.dev(/|$)" |
              head -n1 || true
          }

          echo "Waiting for Cloudflare preview deployment for commit: $SHA"

          while [ "$SECONDS" -lt "$deadline" ]; do
            deployments_json="$(gh api "repos/$REPO/deployments?sha=$SHA&per_page=100" 2>/dev/null || echo '[]')"
            deployment_count="$(echo "$deployments_json" | jq 'length')"

            if [ "$deployment_count" -gt 0 ]; then
              while IFS= read -r deployment_id; do
                statuses_json="$(gh api "repos/$REPO/deployments/$deployment_id/statuses?per_page=100" 2>/dev/null || echo '[]')"
                latest_status="$(echo "$statuses_json" | jq 'first')"
                state="$(echo "$latest_status" | jq -r '.state // empty')"
                environment_url="$(echo "$latest_status" | jq -r '.environment_url // empty')"
                description="$(echo "$latest_status" | jq -r '.description // empty')"
                log_url="$(echo "$latest_status" | jq -r '.log_url // empty')"

                if [ -n "$state" ]; then
                  echo "deployment=$deployment_id state=$state url=$environment_url desc=$description"
                fi

                normalized_environment_url="$(extract_pages_url "$environment_url")"

                if [ "$state" = "success" ] && [ -n "$normalized_environment_url" ]; then
                  echo "Preview is ready: $normalized_environment_url"
                  echo "preview_url=$normalized_environment_url" >> "$GITHUB_OUTPUT"
                  exit 0
                fi

                if [ "$state" = "failure" ] || [ "$state" = "error" ]; then
                  echo "A deployment reported $state for deployment $deployment_id"
                  if [ -n "$log_url" ]; then
                    echo "Deployment log: $log_url"
                  fi
                fi
              done < <(echo "$deployments_json" | jq -r 'sort_by(.created_at) | reverse | .[].id')
            fi

            # Fallback to Cloudflare check-runs when deployment statuses are unavailable.
            checks_json="$(gh api "repos/$REPO/commits/$SHA/check-runs?per_page=100" 2>/dev/null || echo '{"check_runs":[]}')"
            cf_checks="$(echo "$checks_json" | jq '[.check_runs[] | select((.name | ascii_downcase | contains("cloudflare")) or ((.app.slug // "") | ascii_downcase | contains("cloudflare")))]')"
            cf_count="$(echo "$cf_checks" | jq 'length')"

            if [ "$cf_count" -gt 0 ]; then
              echo "Found Cloudflare check-runs: $cf_count"

              latest_cf_checks="$(echo "$cf_checks" | jq '[map(. + {key: (((.app.slug // "") + "::" + (.name // "")) )}) | sort_by(.key, .completed_at // .started_at // "", .id) | group_by(.key) | map(last) | .[]]')"
              latest_failed_count="$(echo "$latest_cf_checks" | jq '[.[] | select(.status == "completed" and (.conclusion == "failure" or .conclusion == "timed_out" or .conclusion == "cancelled" or .conclusion == "action_required"))] | length')"

              if [ "$latest_failed_count" -gt 0 ]; then
                echo "Cloudflare check-run failed for commit $SHA"
                echo "$latest_cf_checks" | jq -r '.[] | "name=\(.name) status=\(.status) conclusion=\(.conclusion) details=\(.details_url)"'
                exit 1
              fi

              success_payload="$(echo "$latest_cf_checks" | jq -r '.[] | select(.status == "completed" and .conclusion == "success") | [.output.title // "", .output.summary // "", .details_url // ""] | join("\n")')"
              preview_url="$(extract_pages_url "$success_payload")"

              if [ -n "$preview_url" ]; then
                echo "Preview URL resolved from check-run: $preview_url"
                echo "preview_url=$preview_url" >> "$GITHUB_OUTPUT"
                exit 0
              fi
            fi

            echo "Cloudflare preview not ready yet, retrying in ${interval}s..."
            sleep "$interval"
          done

          echo "Timed out waiting for Cloudflare preview deployment for commit $SHA"
          exit 1

  run-e2e:
    name: Run Playwright E2E
    needs: [resolve-e2e-branch, wait-cloudflare-preview]
    if: |
      always() &&
      needs.resolve-e2e-branch.result == 'success' &&
      (needs.wait-cloudflare-preview.result == 'success' || (github.event_name == 'workflow_dispatch' && needs.wait-cloudflare-preview.result == 'skipped'))
    runs-on: ubuntu-latest
    timeout-minutes: 45
    env:
      BASE_URL: ${{ needs.wait-cloudflare-preview.outputs.preview_url || inputs.preview_url }}
      SUPABASE_ANON_KEY: ${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY || secrets.SUPABASE_ANON_KEY }}
      E2E_REF: ${{ needs.resolve-e2e-branch.outputs.e2e_ref }}

    steps:
      - name: Checkout E2E repository
        uses: actions/checkout@v4
        with:
          repository: koreyba/EverFreeNote-e2e
          ref: ${{ needs.resolve-e2e-branch.outputs.e2e_ref }}
          path: e2e

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: npm
          cache-dependency-path: e2e/package-lock.json

      - name: Install dependencies
        working-directory: e2e
        run: npm ci

      - name: Install Playwright browsers
        working-directory: e2e
        run: npx playwright install --with-deps

      - name: Run E2E tests
        id: run-e2e-tests
        continue-on-error: true
        env:
          PLAYWRIGHT_JSON_OUTPUT_NAME: results.json
        working-directory: e2e
        run: npm run test -- --reporter=html,json

      - name: Add visual summary
        if: always()
        env:
          E2E_STEP_OUTCOME: ${{ steps.run-e2e-tests.outcome }}
        run: |
          node <<'NODE'
          const fs = require('fs');
          const path = require('path');

          const summaryFile = process.env.GITHUB_STEP_SUMMARY;
          const previewUrl = process.env.BASE_URL || 'n/a';
          const repoRef = 'koreyba/EverFreeNote-e2e@' + (process.env.E2E_REF || 'master');
          const overallOutcome = process.env.E2E_STEP_OUTCOME || 'unknown';

          const reportPath = path.resolve('e2e', 'results.json');
          const counts = { passed: 0, failed: 0, flaky: 0, skipped: 0 };
          const failedItems = [];

          const titleFor = (parts, title) => {
            const clean = [...parts, title].filter(Boolean);
            return clean.join(' > ');
          };

          const walkSuite = (suite, titleParts = []) => {
            const nextParts = suite.title ? [...titleParts, suite.title] : titleParts;

            for (const spec of suite.specs || []) {
              const specTitle = titleFor(nextParts, spec.title);
              for (const test of spec.tests || []) {
                const status = test.status;
                if (status === 'expected') counts.passed += 1;
                else if (status === 'flaky') counts.flaky += 1;
                else if (status === 'skipped') counts.skipped += 1;
                else counts.failed += 1;

                if (status !== 'expected' && status !== 'skipped') {
                  const firstFailedResult = (test.results || []).find((result) => result.status !== 'passed');
                  const firstError = firstFailedResult?.errors?.[0];
                  const errorSnippet = firstError?.message
                    ? firstError.message.split('\n')[0]
                    : 'No error message captured';
                  failedItems.push({
                    project: test.projectName || 'unknown',
                    title: specTitle,
                    location: `${spec.file || 'unknown'}:${spec.line || 0}`,
                    error: errorSnippet,
                  });
                }
              }
            }

            for (const child of suite.suites || []) {
              walkSuite(child, nextParts);
            }
          };

          if (fs.existsSync(reportPath)) {
            const report = JSON.parse(fs.readFileSync(reportPath, 'utf8'));
            for (const suite of report.suites || []) {
              walkSuite(suite, []);
            }
          }

          const total = counts.passed + counts.failed + counts.flaky + counts.skipped;
          const headline = overallOutcome === 'success' ? '✅ E2E Passed' : '❌ E2E Failed';

          let md = '';
          md += `## ${headline}\n\n`;
          md += `- **Preview URL:** ${previewUrl}\n`;
          md += `- **Test repository:** ${repoRef}\n\n`;
          md += '| Metric | Count |\n';
          md += '|---|---:|\n';
          md += `| Total | ${total} |\n`;
          md += `| Passed | ${counts.passed} |\n`;
          md += `| Failed | ${counts.failed} |\n`;
          md += `| Flaky | ${counts.flaky} |\n`;
          md += `| Skipped | ${counts.skipped} |\n\n`;

          if (failedItems.length > 0) {
            md += '<details>\n';
            md += `<summary>Failed tests (${failedItems.length})</summary>\n\n`;
            for (const item of failedItems.slice(0, 20)) {
              md += `- **[${item.project}]** ${item.title}  \n`;
              md += `  \`${item.location}\`  \n`;
              md += `  ${item.error}\n`;
            }
            if (failedItems.length > 20) {
              md += `\n- ... and ${failedItems.length - 20} more\n`;
            }
            md += '\n</details>\n';
          }

          fs.appendFileSync(summaryFile, md);
          NODE

      - name: Upload Playwright report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report-${{ github.run_id }}
          path: |
            e2e/playwright-report
            e2e/test-results
            e2e/results.json
          if-no-files-found: ignore
          retention-days: 14

      - name: Mark job as failed when E2E failed
        if: steps.run-e2e-tests.outcome != 'success'
        run: exit 1
