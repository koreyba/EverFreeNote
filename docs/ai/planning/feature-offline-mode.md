---
phase: planning
title: План работ по оффлайн-режиму
description: Этапы, задачи и приоритеты
---

# План работ

## Этапы высокого уровня
1) Подготовка инфраструктуры
   - [ ] Ввести типы/интерфейсы core (CachedNote, Mutation, SyncState, StorageAdapter, SyncManager).
   - [ ] Подготовить адаптеры хранилища: web (IndexedDB), mobile (SQLite/AsyncStorage + NetInfo).
   - [ ] Закрепить лимит кеша ~100 МБ и политику очистки (LRU/updated_at).

2) Очередь и кеш
   - [ ] Реализовать mutation queue с tempId, статусами pending/failed/synced.
   - [ ] Реализовать кеш с read-through и проверкой лимита.
   - [ ] Обновить UI-хуки для работы через очередь/кеш (оптимистичные обновления).

3) Синхронизация
   - [ ] Синк-менеджер: batch/serial, retry с backoff, остановка при отсутствии прогресса.
   - [ ] Авто-триггеры синка (online, таймер).
   - [ ] Обработка конфликтов: last-write-wins + создание копии при конфликте.

4) UX/поведение
   - [ ] Сообщение об оффлайне/недоступности поиска (минимальное).
   - [ ] Отображение pending/failed (можно отложить, если не блокирует).
   - [ ] Проверка перезапуска: данные и очередь сохраняются.

5) Тестирование
   - [ ] Юнит-тесты cache/queue/sync.
   - [ ] Интеграционные сценарии offline→online, лимит кеша, конфликты.
   - [ ] E2E (web): оффлайн использование, перезапуск, авто-синк.

## Декомпозиция задач
- Кеш (IndexedDB/SQLite): CRUD, лимит 100 МБ, LRU/updated_at, измерение объёма.
- Очередь: enqueue/dequeue, tempId, сериализация в хранилище, идемпотентность.
- Синк: батчи, backoff, маркеры прогресса, перевод failed в повторные попытки при новом online.
- Конфликты: политика last-write-wins, дубликат при конфликте, логирование.
- Поиск: оставить только онлайн; оффлайн-поиск обозначить как future flag.
- UI: использование статусов isOffline/pendingCount/hasFailed; сообщение «поиск недоступен оффлайн».
- Логи/метрики (минимально): счётчик неудачных попыток синка, время последнего успешного синка.

## Риски и смягчение
- Измерение объёма кеша: использовать подсчёт размера записей; при ошибке считать по числу записей как fallback.
- Потери данных при сбое синка: не удалять из очереди до подтверждения сервера; хранить клиентский updated_at.
- Производительность: избегать больших серийных операций в UI-потоке (IndexedDB/SQLite — батчи и воркеры, если потребуется).
- Различия web/mobile: всё, что возможно, держать в ядре; в адаптерах — только особенности платформ.
