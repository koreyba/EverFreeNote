---
phase: requirements
title: Requirements & Problem Understanding
description: Clarify the problem space, gather requirements, and define success criteria
---

# Requirements & Problem Understanding

## Problem Statement
**What problem are we solving?**

- Потеря правок при закрытии вкладки, краше или переключении заметок из-за отсутствия автосейва и локального восстановления.
- Все пользователи веб-редактора (онлайн/офлайн) затронуты; текущая модель — только ручной Save.
- Риск для длинных сессий ввода: между ручными сохранениями данные не защищены; офлайн сценарии не покрыты.

## Goals & Objectives
**What do we want to achieve?**

- Автосейв с задержкой по умолчанию 1.5 с (конфигурируемый диапазон 1–2 с) после остановки ввода; не триггерить без изменений (diff check).
- Устойчивость: восстановление правок после закрытия/рефреша/офлайна за счёт локального кеша и overlay.
- Индикация: Saving…/Saved на кнопке, корректные pending/failed счётчики; статус не мерцает (отображается ≥500 мс).
- Не цели: менять бэкенд-схему, добавлять новую стратегию конфликтов (оставляем LWW).

## User Stories & Use Cases
**How will users interact with the solution?**

- Как автор, закрывая вкладку, хочу, чтобы черновик сохранился автоматически.
- Как автор, при краше/рефреше браузера хочу восстановить последние правки из кеша.
- Как автор, переключаясь на другую заметку, хочу, чтобы текущая была сохранена.
- Edge cases: офлайн режим (enqueue + overlay), длинные заметки, постоянный ввод (дебаунс 1–2 с и ограничение частоты).

## Success Criteria
**How will we know when we're done?**

- Автосейв срабатывает через 1.5 с (конфигурируемо 1–2 с) тишины после изменения title/tags/body; не срабатывает без diff.
- При перезагрузке/закрытии вкладки правки доступны из локального кеша/overlay.
- В оффлайне изменения появляются в UI сразу (overlay), очередь содержит pending; после онлайна очередь очищается, overlay синхронизируется.
- Кнопка Save показывает Saving…/Saved; статус отображается ≥500 мс после завершения операции, не мерцает при частом вводе.
- Частота автосейва при непрерывном вводе: не чаще одного сохранения каждые 2 с (дебаунс/дросселирование).
- Ошибки записи в кеш/очередь отражаются в failedCount/уведомлении; данные не теряются.
- Все автосейвы идут через OfflineQueueService/OfflineSyncManager, без прямых сетевых вызовов; payload — только изменённые поля + clientUpdatedAt.

## Constraints & Assumptions
**What limitations do we need to work within?**

- Дебаунс по умолчанию 1.5 с (диапазон 1–2 с, конфигурируемый). LWW конфликт-стратегия сохраняется.
- Используем существующее: webOfflineStorageAdapter, OfflineQueueService, OfflineCacheService, OfflineSyncManager, applyNoteOverlay.
- Payload автосейва — только изменённые поля (title/description/tags) + clientUpdatedAt (+ id/version при наличии); автосейв не триггерится без изменений.
- Частота автосейва ограничена (не чаще 1 раз в 2 с) при непрерывном вводе.
- Compaction/enforceLimit хранилища/очереди задействованы; предполагаем достаточный лимит для ≥100 автосейвов в офлайне.

## Questions & Open Items
**What do we still need to clarify?**

- Нужно ли обязательное отображение “last saved at” (время) или достаточно текста Saving…/Saved?
- Оставляем ли дросселирование 1 сохранение/2 с и минимум 500 мс показа статуса как константы, или делаем конфиг?
- Какой кап для очереди/кеша в офлайне считаем допустимым (e.g., ≥100 автосейвов) — зафиксировать числом или метрикой?
