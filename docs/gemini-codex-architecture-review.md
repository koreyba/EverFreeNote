# Совместный архитектурный обзор (Gemini & Codex)

**Ревизия 1 (Gemini):** 29 ноября 2025  
- Монолит `app/page.tsx` объединяет состояние, данные и UI.  
- Нет сервисного слоя; UI ходит напрямую в Supabase.  
- Используются браузерные API и DOM-редактор (tiptap), что усложняет перенос на React Native.  
- Риск XSS при выводе HTML без гарантированной очистки.  
- Хостинг Cloudflare Pages (Free) = только SPA, без API Routes/SSR.

**Ревизия 2 (Codex):** 29 ноября 2025  
- Требуется декомпозиция `app/page.tsx` на контейнеры/компоненты.  
- Нужен общий сервисный слой для CRUD/поиска/импорта поверх Supabase (Web + RN), вместо прямых вызовов из UI.  
- Обязательная санитизация HTML перед `dangerouslySetInnerHTML` (XSS).  
- Единый экземпляр Supabase-клиента/провайдера вместо множества подписок.  
- Для React Native: убрать прямые обращения к `window`/`localStorage`, вынести пагинацию/поиск в чистые хуки, определиться с редактором (WebView или markdown/ограниченный HTML).

**Ревизия 3 (Gemini):** 29 ноября 2025  
- Подтверждено: Cloudflare Pages → только SPA, сервисный слой клиентский.  
- Рекомендован `SupabaseProvider` для единого клиента и Auth.  
- Исправить кодировку и актуализировать `README.md`, `ARCHITECTURE.md`.

**Ревизия 4 (Codex):** 29 ноября 2025  
- Согласен с SPA-ограничением: никакого SSR/server actions, весь доступ к Supabase только из клиента; сервисы/контроллеры должны быть чисто клиентскими и совместимыми с `output: 'export'`.  
- Санитизация обязана быть частью клиентского pipeline (DOMPurify) перед любым `dangerouslySetInnerHTML`, включая импорт ENEX.  
- При декомпозиции избегать прямых зависимостей на `window`; оборачивать браузерные API и хранение (theme, auth cache) через адаптеры.  
- Уточнить поисковый слой: единый компонент результатов и общий вызов FTS/ILIKE из `lib/supabase/search.ts`.

**Ревизия 5 (Gemini):** 29 ноября 2025  
- Подтверждена готовность согласовать общий план.  
- Принято: декомпозиция `app/page.tsx` и сервисный слой остаются клиентскими в рамках SPA.  
- Принято: `SupabaseProvider` и выделенный контроллер/слой (`useNoteAppController`).  
- Принято: исправить документацию и кодировку.

## Совместные шаги
1. Ввести единый Supabase client provider и сервисный слой с явным клиентским API (CRUD, поиск, импорт) без серверных роутов.  
2. Декомпозировать `app/page.tsx` на контейнеры (AuthShell/NotesShell/EditorPane/ListPane) и вынести состояние/пагинацию в переиспользуемые хуки.  
3. Санитизировать HTML заметок перед выводом через единый pipeline (DOMPurify); проверять входящие данные при импорте ENEX.  
4. Устранить дублирование поиска: использовать общий компонент результатов и общий вызов FTS/ILIKE.  
5. Подготовить к RN: обернуть browser API, выбрать подход к редактору (WebView/markdown), спланировать кеш/офлайн при необходимости.  
6. Восстановить читаемость документации (`README.md`, `docs/ARCHITECTURE.md`) и синхронизировать с текущей архитектурой.
