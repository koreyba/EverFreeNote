# Руководство по стилям EverFreeNote

## Единый источник истины (Single Source of Truth)

**Критически важно:** Все стили для контента заметок определены в `app/globals.css` в одном месте с использованием **групповых селекторов** `.prose, .ProseMirror`.

### Архитектурное решение

Вместо дублирования стилей или переопределений, мы используем **единые правила CSS** для обоих режимов:

```css
/* ✅ ПРАВИЛЬНО - Единый источник истины */
.prose h1,
.ProseMirror h1 {
  margin-top: 0;
  margin-bottom: 0.8888889em;
  line-height: 1.1111111;
  font-size: 2.25em;
}
```

**Не используем:**
- ❌ Дублирование стилей отдельно для `.prose` и `.ProseMirror`
- ❌ Переопределение через "фиксы"
- ❌ `@apply` директивы (могут конфликтовать с Tailwind)

### Почему это важно

1. **Гарантированная консистентность** - изменение в одном месте применяется сразу к обоим режимам
2. **Легкая поддержка** - не нужно искать и обновлять несколько мест
3. **Нет конфликтов** - единый приоритет CSS селекторов
4. **Меньше кода** - нет дублирования

Это обеспечивает единообразие между режимами чтения и редактирования.

## Структура стилей

### 1. Основные переменные цветов

Цветовая схема определена в `@theme` блоке с использованием OKLCH цветового пространства для лучшей согласованности восприятия.

**Светлая тема:**
- Background: `oklch(100% 0 0)` - чистый белый
- Foreground: `oklch(20% 0.01 256)` - темный текст
- Primary: `oklch(60% 0.18 145)` - изумрудно-зеленый
- Card: `oklch(100% 0 0)` - белый для карточек

**Темная тема:**
- Background: `oklch(20% 0.015 256)` - мягкий темно-серый (не чистый черный для уменьшения усталости глаз)
- Foreground: `oklch(95% 0.005 256)` - светлый текст
- Primary: `oklch(65% 0.18 145)` - яркий изумрудный
- Card: `oklch(24% 0.015 256)` - приподнятый от фона для визуальной иерархии

### 2. Prose стили (Typography)

**Единая конфигурация через групповые селекторы:**
```css
.prose, .ProseMirror {
  /* Базовые стили применяются к обеим темам и обоим режимам */
  color: var(--color-foreground);
}

.prose h1, .ProseMirror h1 {
  /* Стили заголовков идентичны в обоих режимах */
}
```

**Ключевые элементы:**
- Заголовки (h1-h6): наследуют `--color-foreground`, жирность 700, специфичные `line-height` для каждого уровня
- Параграфы и списки: `line-height: 1.75`, `margin: 1.25em 0`
- Пустые параграфы: используют zero-width space (`\200B`) для сохранения высоты
- Ссылки: используют `--color-primary` с подчеркиванием
- Код: фон `oklch(96% 0.005 256)`, в темной теме `var(--color-muted)`
- Цитаты: цвет `--color-muted-foreground`, курсив, левая граница

**Важно для синхронизации режимов:**
- Все правила определены ОДИН РАЗ с групповыми селекторами
- Нет дублирования или переопределений
- Специфичные стили редактора (placeholder, cursor) определены отдельно

### 3. Режимы отображения заметок

#### Режим чтения (NoteView)
```tsx
<div className="prose prose-neutral dark:prose-invert prose-lg max-w-none">
  {/* content */}
</div>
```

#### Режим редактирования (RichTextEditor)
```tsx
editorProps: {
  attributes: {
    class: "prose prose-neutral dark:prose-invert prose-lg max-w-none focus:outline-none px-6 py-4"
  }
}
```

**Важно:** Оба режима используют `prose-lg` для единого размера шрифта.

### 4. Компоненты заметок

#### NoteEditor
- **Мемоизация**: Компонент обернут в `React.memo` для предотвращения лишних ре-рендеров
- **Обработчики**: Используются `useCallback` для стабильных ссылок на функции
- Заголовок: `text-2xl font-bold` с прозрачным фоном
- Теги: стандартный Input с лейблом
- Контент: RichTextEditor с теми же стилями, что и в режиме чтения

#### NoteView
- **Мемоизация**: Компонент обернут в `React.memo`
- **Оптимизация**: Санитизированный контент и форматированные даты кешируются через `useMemo`
- Заголовок H1 отображается в контенте (дублируется из header для визуальной консистентности)
- Теги показываются перед контентом
- Контент рендерится с sanitization
- Кнопка Delete имеет правильные стили для темной темы

#### RichTextEditor
- **Оптимизация**: 
  - Конфигурация расширений мемоизирована через `useMemo`
  - `editorProps` также мемоизированы для предотвращения лишних ре-рендеров
- Единый размер `prose-lg` для консистентности
- Отступы `px-6 py-4` для удобной работы
- Минимальная высота 400px для комфортного редактирования

### 5. Специальные элементы

**Подсветка поиска (mark):**
```css
/* Светлая тема */
mark {
  background-color: hsl(var(--primary) / 0.2);
  color: hsl(var(--primary));
}

/* Темная тема */
.dark mark {
  background-color: hsl(var(--primary) / 0.3);
  color: oklch(75% 0.18 145);
}
```

## Принципы дизайна темной темы

1. **Не чистый черный**: используем `oklch(20%)` вместо `oklch(0%)` для снижения усталости глаз
2. **Визуальная иерархия**: карточки светлее фона на 4%, модальные окна еще светлее
3. **Контрастность**: соответствует WCAG AA для доступности
4. **Яркие акценты**: primary цвет ярче в темной теме для лучшей видимости
5. **Читаемость**: мягкие границы между элементами

## Модификация стилей

### Для изменения типографики:
1. Найдите соответствующие селекторы в `app/globals.css` (ищите `.prose, .ProseMirror`)
2. Изменения автоматически применятся к обоим режимам
3. **Никогда не дублируйте стили** - используйте групповые селекторы

### Для изменения цветовой схемы:
1. Измените переменные в `@theme` блоке для светлой темы
2. Измените переменные в `.dark` блоке для темной темы
3. Prose стили автоматически адаптируются через CSS переменные

### Для добавления новых элементов:
1. Добавьте стили используя групповые селекторы: `.prose ELEMENT, .ProseMirror ELEMENT { }`
2. Используйте CSS переменные для цветов
3. Тестируйте в обеих темах и обоих режимах

## ⚠️ Антипаттерны (НЕ делайте так)

### ❌ Дублирование стилей
```css
/* ПЛОХО */
.prose p {
  margin-top: 1.25em;
}

.ProseMirror p {
  margin-top: 1.25em; /* Дублирование! */
}
```

```css
/* ХОРОШО */
.prose p,
.ProseMirror p {
  margin-top: 1.25em; /* Определено один раз */
}
```

### ❌ Переопределения через "фиксы"
```css
/* ПЛОХО */
.prose p {
  line-height: 1.5;
}

/* Фикс для ProseMirror */
.ProseMirror p {
  line-height: 1.5; /* Переопределение */
}
```

### ❌ Специфичность через !important
```css
/* ПЛОХО */
.ProseMirror p {
  margin-top: 1.25em !important; /* Избегайте !important */
}

/* ИСКЛЮЧЕНИЕ - допустимо только для сброса первого/последнего элемента */
.prose > *:first-child {
  margin-top: 0 !important; /* OK - сбрасывает любые другие стили */
}
```

### ❌ Разные значения для одних и тех же свойств
```css
/* ПЛОХО */
.prose p {
  line-height: 1.75;
}

.ProseMirror p {
  line-height: 1.8; /* Разные значения! */
}
```

## Чек-лист перед коммитом

- [ ] Изменения выглядят одинаково в режиме чтения и редактирования
- [ ] Тестирование в светлой теме
- [ ] Тестирование в темной теме
- [ ] Контрастность текста достаточна для чтения
- [ ] Ссылки и интерактивные элементы видны
- [ ] Код и специальные блоки оформлены правильно

## Лучшие практики производительности

### 1. Мемоизация компонентов
```tsx
export const MyComponent = React.memo(function MyComponent(props) {
  // component logic
})
```

**Когда использовать:**
- Компоненты с дорогим рендерингом (например, RichTextEditor)
- Компоненты, которые часто перерисовываются
- Компоненты с большими пропсами

### 2. Мемоизация вычислений
```tsx
const expensiveValue = React.useMemo(() => {
  return computeExpensiveValue(a, b)
}, [a, b])
```

**Когда использовать:**
- Санитизация HTML контента
- Форматирование дат
- Сложные вычисления в render

### 3. Мемоизация обработчиков
```tsx
const handleChange = React.useCallback((e) => {
  onChange(e.target.value)
}, [onChange])
```

**Когда использовать:**
- Передача колбэков в дочерние компоненты
- Обработчики событий в мемоизированных компонентах

### 4. Правильная структура зависимостей
- Всегда включайте все используемые значения в массив зависимостей
- Используйте ESLint правило `react-hooks/exhaustive-deps`
- Выносите константы из компонента, если они не зависят от пропсов/состояния

### 5. Оптимизация конфигураций
- Конфигурации библиотек (TipTap extensions) должны быть мемоизированы
- Используйте пустой массив зависимостей `[]` для статических конфигураций
- Не создавайте объекты/массивы в render без необходимости

## Архитектурные принципы

### Separation of Concerns (Разделение ответственности)
- **Презентационные компоненты** (`NoteView`, `NoteEditor`) - только отображение
- **Контейнеры** (`NotesShell`) - логика и состояние
- **Хуки** (`useNoteAppController`) - бизнес-логика
- **Сервисы** (`SanitizationService`) - утилиты и обработка данных

### Single Responsibility Principle
- Каждый компонент отвечает за одну задачу
- RichTextEditor - только редактирование
- NoteView - только просмотр
- NoteEditor - только форма редактирования

### Don't Repeat Yourself (DRY)
- Общие стили в `globals.css`
- Переиспользуемые компоненты UI в `components/ui/`
- Единая конфигурация prose для обоих режимов

### Accessibility (Доступность)
- Соблюдение контрастности WCAG AA
- Семантичная HTML разметка (h1, h2, p, etc.)
- Правильные ARIA атрибуты где необходимо
- Keyboard navigation support
