# Отчет об архитектурном аудите EverFreeNote

**Дата:** 29 ноября 2025  
**Ревьювер:** GitHub Copilot (Codex)

## Краткое резюме
Приложение построено как SPA на Next.js 15/React 19 с Supabase и React Query. Архитектура зависит от единого крупного компонента `app/page.tsx`, в котором смешаны auth, загрузка данных, поиск, импорт и UI. Отсутствует сервисный слой; UI напрямую работает с Supabase. Это усложняет перенос логики в React Native и создает риски (XSS, лишние соединения, дублирование поиска).

## Основные проблемы
1) XSS: показ заметок через `dangerouslySetInnerHTML` без очистки (`app/page.tsx:822`), импорт ENEX может занести произвольный HTML.  
2) Жизненный цикл Supabase: `createClient()` вызывается в компоненте и хуках на каждом рендере → лишние клиенты/подписки auth, сложно выделить общий слой.  
3) Монолит `app/page.tsx` (>850 строк) объединяет бизнес-логику и представление; нет переиспользуемого ядра.  
4) Дублирование поиска: FTS/ILIKE логика и UI внутри `app/page.tsx` не используют `components/SearchResults` и `lib/supabase/search.ts`; fallback ILIKE игнорируется.  
5) Сильная связка UI↔Supabase: импорт (`lib/enex/note-creator.ts`) и CRUD вызывают Supabase напрямую, нет абстракций (repository/service), что блокирует перенос на RN.  
6) Документация повреждена (моджибейк в `README.md`, `docs/ARCHITECTURE.md`), затрудняет поддержку и планирование.

## Готовность к React Native
- Нет общего доменного/сервисного слоя для CRUD/поиска/импорта — RN не может переиспользовать логику.  
- Пагинация/поиск зашиты в компоненты, не вынесены в чистые хуки/функции.  
- Инициализация Supabase бросает ошибку при отсутствии env на этапе импорта — не совместимо с сборкой/тестами RN.

## Рекомендации (приоритет)
1) Санитизировать HTML заметок в `app/page.tsx` (DOMPurify) перед `dangerouslySetInnerHTML`.  
2) Ввести единый Supabase client provider; auth-подписку выполнять там, чтобы не плодить клиентов/вебсокетов.  
3) Выделить `notesService`/`searchService` (CRUD, поиск, импорт) как чистые функции поверх Supabase; UI и RN используют этот слой.  
4) Убрать дублирование поиска: использовать `components/SearchResults` и `lib/supabase/search.ts`, включая ILIKE fallback.  
5) Декомпозировать `app/page.tsx` на контейнеры (AuthShell, NotesShell, EditorPane, ListPane); состояние и пагинацию вынести в переиспользуемые хуки/машины.  
6) Исправить кодировку `README.md` и `docs/ARCHITECTURE.md`.  
7) Оптимизировать импорт: батч-дубликаты/вставки или кэш заголовков; проводить через сервисный слой (портируемо на RN).

## Вопросы для уточнения
- Нужен ли offline-first на мобильных? Если да — планировать локальное хранилище (SQLite/MMKV) и слой синхронизации.  
- Остается ли Supabase единственным backend или нужен абстрактный API за сервисным слоем?  
- Планируется ли шарить UI-праймитивы (react-native-web) или только доменный/данный слой?
## Дополнение: учет ограничений (Supabase + Cloudflare Pages SPA)
- Бэкенд фиксирован на Supabase (BaaS); сервисный слой должен работать поверх Supabase RPC/таблиц без серверных роутов Next.
- Cloudflare Pages (Free) = только статический SPA (`output: export`), без API Routes/Server Components/SSR; все вызовы идут напрямую из клиента в Supabase.
- При декомпозиции `app/page.tsx` избегать server actions; контроллеры/хуки и провайдер Supabase остаются полностью клиентскими.
- Санитизация, поиск, CRUD выполняются на клиенте через Supabase SDK; не рассчитывать на серверные миддлвары.
